"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = tslib_1.__importDefault(require("./config"));
const inline_config_1 = require("./inline_config");
const rules_1 = tslib_1.__importDefault(require("./rules"));
const issue_1 = tslib_1.__importDefault(require("./issue"));
const custom_errors_1 = tslib_1.__importDefault(require("./utils/custom-errors"));
const read_config_1 = require("./read-config");
const array_1 = require("./utils/array");
/**
 * Apply the raw-ignore-regex option.
 * Return the modified html, and a function that recovers line/column
 * numbers of issues.
 */
function raw_ignore_regex(html, options) {
    const ignore = options["raw-ignore-regex"];
    if (!ignore) {
        return html;
    }
    // TODO: Remove `as ...` after adding validation to `x-regex` property in config files
    return html.replace(new RegExp(ignore, "gm"), function (match) {
        return match.replace(/[^\n\t\n\r]/g, "Â¤");
    });
}
function merge_inline_config(base_config, new_config) {
    const merged_config = Object.keys(new_config).reduce((merged_config, rule_name) => {
        if (base_config[rule_name]) {
            merged_config[rule_name] = {
                ...base_config[rule_name],
                ...new_config[rule_name]
            };
        }
        else {
            merged_config[rule_name] = new_config[rule_name];
        }
        return merged_config;
    }, {});
    return {
        ...base_config,
        ...merged_config
    };
}
function get_parser(config) {
    if (config === null || config === void 0 ? void 0 : config.parser) {
        try {
            const parser_module = (0, read_config_1.get_module_path)(process.cwd(), config.parser);
            return require(parser_module);
        }
        catch (error) {
            throw new custom_errors_1.default("CORE-04", { module_name: error.meta.module_name });
        }
    }
    // TODO: Switch to import
    // Eslint Typescript recommend using import statement but import return a promise.
    /* eslint-disable-next-line @typescript-eslint/no-var-requires */
    return require("@linthtml/html-parser").default;
}
class Linter {
    constructor(config) {
        this.parse_fn = get_parser(config);
        this.config = new config_1.default(rules_1.default, config);
    }
    /**
     * Lints the HTML with the options supplied in the environments setup.
     */
    lint(html) {
        html = raw_ignore_regex(html, this.config.config);
        const dom = this.parse_fn(html);
        const activated_rules = Object.keys(this.config.activated_rules).map((name) => this.config.activated_rules[name]);
        const domIssues = this.lint_DOM(activated_rules, dom);
        let issues = [...domIssues, ...this.reset_rules()];
        if (this.config.config.maxerr) {
            issues = issues.slice(0, this.config.config.maxerr); // REMOVE: After v1.
        }
        return Promise.resolve(issues);
    }
    lint_DOM(rules, dom) {
        const issues = [];
        // merge with report in call_rule_lint ?
        function report_inline_config(data) {
            const meta = {
                ...data.meta,
                severity: "error",
                code: data.code
            };
            issues.push(new issue_1.default("inline_config", data.position, meta));
        }
        const getIssues = (node, parent_inline_config) => {
            let issues = rules.reduce((issues, rule) => [...issues, ...this.call_rule_lint(rule, node, parent_inline_config)], []);
            if (node.children && node.children.length > 0) {
                let inline_config = {
                    ...parent_inline_config
                };
                node.children.forEach((child) => {
                    const extracted_inline_config = (0, inline_config_1.extract_inline_config)(child, this.config, report_inline_config);
                    inline_config = merge_inline_config(inline_config, extracted_inline_config);
                    issues = [...issues, ...getIssues(child, inline_config)];
                });
            }
            return issues;
        };
        let inline_config = {};
        const rules_issues = dom.children.map((node) => {
            const extracted_inline_config = (0, inline_config_1.extract_inline_config)(node, this.config, report_inline_config);
            inline_config = merge_inline_config(inline_config, extracted_inline_config);
            return getIssues(node, inline_config);
        });
        return [...issues, ...(0, array_1.flatten)(rules_issues)];
    }
    // TODO: Remove after v1
    call_rule_lint(rule, node, inline_config) {
        var _a, _b, _c, _d;
        const issues = [];
        function report(data) {
            const meta = {
                ...data.meta,
                severity: rule.severity,
                code: data.code,
                message: data.message
            };
            issues.push(new issue_1.default(rule.name, data.position, meta));
        }
        if (((_a = inline_config[rule.name]) === null || _a === void 0 ? void 0 : _a.disabled) === true) {
            // inline_config[rule.name]?.disabled
            return issues;
        }
        const rule_config = (_c = (_b = inline_config[rule.name]) === null || _b === void 0 ? void 0 : _b.config) !== null && _c !== void 0 ? _c : this.config.legacy_config[rule.name];
        const global_config = ((_d = inline_config[rule.name]) === null || _d === void 0 ? void 0 : _d.config)
            ? {
                ...this.config.legacy_config,
                [rule.name]: inline_config[rule.name].config
            }
            : this.config.legacy_config;
        rule.lint(node, rule_config, {
            report,
            rules: this.config.activated_rules,
            global_config
        });
        return issues;
    }
    reset_rules() {
        const activated_rules = Object.keys(this.config.activated_rules);
        return activated_rules.reduce((issues, name) => {
            var _a, _b;
            const rule = this.config.getRule(name);
            const r = (_b = (_a = rule.end) === null || _a === void 0 ? void 0 : _a.call(rule)) !== null && _b !== void 0 ? _b : [];
            return [...issues, ...r];
        }, []);
    }
}
exports.default = Linter;
