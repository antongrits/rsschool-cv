"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
// @ts-ignore
const html_parser_1 = tslib_1.__importDefault(require("@linthtml/html-parser"));
const config_1 = tslib_1.__importDefault(require("./config"));
const inline_config_1 = tslib_1.__importDefault(require("./inline_config"));
const rules_1 = tslib_1.__importDefault(require("../rules"));
const dom_utils_1 = require("@linthtml/dom-utils");
const array_1 = require("../utils/array");
/**
 * Apply the raw-ignore-regex option.
 * Return the modified html, and a function that recovers line/column
 * numbers of issues.
 */
function rawIgnoreRegex(html, opts) {
    const ignore = opts["raw-ignore-regex"];
    if (!ignore) {
        return html;
    }
    return html.replace(new RegExp(ignore, "gm"), function (match) {
        return match.replace(/[^\n\t\n\r]/g, "Â¤");
    });
}
class Linter {
    constructor(_rules, ..._config) {
        const config = _config.reduce((obj, cell) => ({
            ...obj,
            ...cell
        }), {});
        delete config.ignoreFiles;
        this.config = config;
        _rules = _rules || rules_1.default;
        this.rules = new config_1.default(_rules);
        this.inlineConfig = new inline_config_1.default(this.rules);
    }
    use(plugin) {
        if (plugin.rules) {
            plugin.rules.forEach((rule) => this.rules.addRule(rule));
        }
    }
    /**
     * Lints the HTML with the options supplied in the environments setup.
     * @param {String} html - the html as a string to lint.
     * @returns {import('../issue')[]}
     */
    lint(html) {
        let issues = [];
        this.inlineConfig = new inline_config_1.default(this.rules);
        this.rules.initOptions(this.config);
        html = rawIgnoreRegex(html, this.config);
        const dom = (0, html_parser_1.default)(html);
        issues = issues.concat(this.setupInlineConfigs(dom));
        try {
            issues = issues.concat(this.lintDom(dom, this.config));
        }
        finally {
            issues = issues.concat(this.resetRules(this.config));
        }
        if (this.config.maxerr) {
            issues = issues.slice(0, this.config.maxerr);
        }
        return Promise.resolve(issues);
    }
    // Here ignore ts error as "dom" is special rule.
    lintDom(dom, opts) {
        // @ts-ignore
        return this.rules.getRule("dom").lint(dom, opts, this.inlineConfig);
    }
    resetRules(opts) {
        const rules = this.rules.getAllRules().map((rule) => {
            const r = rule.end && rule.end(opts);
            return r || [];
        });
        return (0, array_1.flatten)(rules);
    }
    setupInlineConfigs(dom) {
        let issues = [];
        const { inlineConfig } = this;
        function feedComments(element) {
            if ((0, dom_utils_1.is_comment_node)(element)) {
                issues = issues.concat(inlineConfig.feedComment(element));
            }
            if (element.children) {
                element.children.map(feedComments);
            }
        }
        dom.children.forEach(feedComments.bind(this));
        return issues;
    }
}
exports.default = Linter;
