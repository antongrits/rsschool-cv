"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dom_utils_1 = require("@linthtml/dom-utils");
const RULE_NAME = "doctype-first";
function validateConfig(option) {
    if (typeof option === "string" && option !== "smart") {
        throw new Error(`Configuration for rule "${RULE_NAME}" is invalid: Only "smart" is accepted as string value`);
    }
    if (typeof option !== "boolean" && typeof option !== "string") {
        throw new Error(`Configuration for rule "${RULE_NAME}" is invalid: Expected boolean got ${typeof option}`);
    }
    return option;
}
function is_whitespace(node) {
    return (0, dom_utils_1.is_text_node)(node) && /^[ \t\n\f\r]*$/.test(node.data);
}
function lint(node, mode, { report }) {
    // CHECK if parent if first child instead
    // USE util function to check node type
    // @ts-ignore
    if (this.passedFirst || (0, dom_utils_1.is_comment_node)(node) || is_whitespace(node)) {
        return;
    }
    // @ts-ignore
    this.passedFirst = true;
    if ((0, dom_utils_1.is_directive_node)(node) && node.name.toUpperCase() === "!DOCTYPE") {
        return;
    }
    // If the option is 'smart', fail only if a head tag is present.
    if (mode === "smart" && !((0, dom_utils_1.is_tag_node)(node) && node.name.toLowerCase() === "head")) {
        return;
    }
    report({
        code: "E007",
        position: node.open ? node.open.loc : node.loc
    });
}
exports.default = {
    name: RULE_NAME,
    validateConfig,
    lint,
    passedFirst: false,
    end() {
        // @ts-ignore
        this.passedFirst = false;
        return [];
    }
};
