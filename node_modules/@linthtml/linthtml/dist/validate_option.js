"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create_number_validator = exports.create_list_value_validator = exports.create_string_or_regexp_validator = exports.is_boolean = void 0;
const util_1 = require("util");
const { isRegExp } = util_1.types;
// TODO: Send `rule_name` to the actual validation function?
// TODO: Create error code for messages
function is_boolean(rule_name) {
    return function (option) {
        if (typeof option !== "boolean") {
            throw new Error(`Configuration for rule "${rule_name}" is invalid: Expected boolean got ${typeof option}.`);
        }
        return option;
    };
}
exports.is_boolean = is_boolean;
function create_string_or_regexp_validator(rule_name, allow_empty_string = true) {
    return function (option) {
        if ((typeof option === "string" && (allow_empty_string || option !== "")) || isRegExp(option) === true) {
            return option;
        }
        if (!allow_empty_string && typeof option === "string") {
            throw new Error(`Configuration for rule "${rule_name}" is invalid: You provide an empty string value.`);
        }
        throw new Error(`Configuration for rule "${rule_name}" is invalid: Expected string or RegExp got ${typeof option}.`);
    };
}
exports.create_string_or_regexp_validator = create_string_or_regexp_validator;
function list_value_error_message(value_list) {
    const list_copy = [...value_list];
    if (value_list.length > 1) {
        const last_value = list_copy.pop();
        return `Accepted values are ${list_copy.map((_) => `"${_}"`).join(", ")} and "${last_value}"`;
    }
    return `Accepted value is ${list_copy[0]}`;
}
function create_list_value_validator(rule_name, values, allow_reg = true) {
    const type_error = (rule_name, option) => `Configuration for rule "${rule_name}" is invalid: Expected string${allow_reg ? " or RegExp" : ""} got ${typeof option}.`;
    if (Array.isArray(values) === false || values.some((_) => typeof _ !== "string")) {
        throw new Error("You must provide a array of string"); // CORE error message?
    }
    // TODO: need same rule without regexp
    return function (option) {
        if (typeof option !== "string" && (allow_reg === false || isRegExp(option) === false)) {
            throw new Error(type_error(rule_name, option));
        }
        if (values.indexOf(option) === -1 && isRegExp(option) === false) {
            throw new Error(`Configuration for rule "${rule_name}" is invalid: "${option}" is not accepted. ${list_value_error_message(values)}.`);
        }
        return option;
    };
}
exports.create_list_value_validator = create_list_value_validator;
function create_number_validator(rule_name, allow_neg = true) {
    return function (option) {
        if (typeof option !== "number") {
            throw new Error(`Configuration for rule "${rule_name}" is invalid: Expected number got ${typeof option}.`);
        }
        if (allow_neg === false && option < 0) {
            throw new Error(`Configuration for rule "${rule_name}" is invalid: Only positive indent value are allowed.`);
        }
        return option;
    };
}
exports.create_number_validator = create_number_validator;
