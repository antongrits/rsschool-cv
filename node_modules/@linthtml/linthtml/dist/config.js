"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NonExistingRule extends Error {
    constructor(rule_name) {
        super(`Rule "${rule_name}" does not exist.`);
        this.rule_name = rule_name;
        this.name = "NonExistingRule";
        this.rule_name = rule_name;
    }
}
class InvalidRuleConfig extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidRuleConfig";
    }
}
function is_valid_string(str) {
    return ["error", "warning", "off"].indexOf(str) !== -1;
}
// TODO: Create ENUM for severity?
function get_severity(config) {
    switch (typeof config) {
        case "boolean":
            return "error";
        case "string":
            return config;
        default:
            return get_severity(config[0]); // throw an error for objects?
    }
}
function should_active_rule(options, ruleName) {
    switch (typeof options) {
        case "boolean":
            return options;
        case "string":
            if (is_valid_string(options)) {
                return options !== "off";
            }
            throw new InvalidRuleConfig(`Invalid Config for rule "${ruleName}" - Unexpected string value "${options}"`);
        default:
            if (Array.isArray(options)) {
                return should_active_rule(options[0], ruleName);
            }
            throw new InvalidRuleConfig(`Invalid Config for rule "${ruleName}" - Unexpected value "${JSON.stringify(options)}"`);
    }
}
function extract_rule_config(config, ruleName) {
    if (typeof config !== "object") {
        return null;
    }
    if (Array.isArray(config) === false) {
        throw new InvalidRuleConfig(`Invalid Config for rule "${ruleName}"`); // todo: Create nice error
    }
    const ruleConfig = config[1];
    return ruleConfig;
}
function generate_rules_from_options(rule) {
    return rule.options.reduce((rules, option) => {
        if (option.name) {
            rules[option.name] = {
                name: option.name,
                validateConfig: option.validateConfig,
                configTransform: option.configTransform,
                filter: option.filter,
                lint: option.lint || rule.lint // otherwise some "rules" won't be called
            };
        }
        return rules;
    }, {});
}
function extract_all_rules(rules) {
    const extracted_rules = rules.reduce((extracted, rule) => {
        if (rule.options !== undefined) {
            const optionsRules = generate_rules_from_options(rule);
            extracted = { ...extracted, ...optionsRules };
        }
        extracted[rule.name] = rule;
        return extracted;
    }, {});
    delete extracted_rules.maxerr;
    // not considered as rules
    delete extracted_rules["text-ignore-regex"]; // display warning message for deprecation
    delete extracted_rules["raw-ignore-regex"];
    delete extracted_rules["attr-name-ignore-regex"];
    delete extracted_rules["id-class-ignore-regex"];
    delete extracted_rules["line-max-len-ignore-regex"];
    delete extracted_rules.ignoreFiles;
    return extracted_rules;
}
// TODO: Also validate config for "text-ignore-regex", "maxerr"...
class Config {
    constructor(rules = [], config) {
        var _a, _b;
        this.legacy_config = {};
        // TODO: Remove after v1. No more nested rules
        const plugins_rules = (_a = config === null || config === void 0 ? void 0 : config.plugins_rules) !== null && _a !== void 0 ? _a : {};
        this.rules = { ...extract_all_rules(rules), ...plugins_rules };
        this.activated_rules = {};
        this.config = config;
        if ((_b = this.config) === null || _b === void 0 ? void 0 : _b.rules) {
            this.activateRules(this.config);
            // TODO: Remove after v1. No more needed
            this.legacy_config = this.generateLegacyConfig(this.config);
        }
    }
    /**
     * Activate rules from a config object
     */
    activateRules(config) {
        const keys = Object.keys(config.rules);
        keys.forEach((rule_name) => {
            const rule = this.getRule(rule_name);
            this.setRuleConfig(rule, config.rules);
        });
    }
    /**
     * Get a rule by name.
     */
    getRule(rule_name) {
        const rule = this.rules[rule_name];
        if (rule === undefined) {
            throw new NonExistingRule(rule_name);
        }
        return rule;
    }
    setRuleConfig(rule, rules_config) {
        if (should_active_rule(rules_config[rule.name], rule.name)) {
            let rule_config = extract_rule_config(rules_config[rule.name], rule.name);
            if (rule_config !== null && rule_config !== undefined) {
                rule_config = rule.configTransform ? rule.configTransform(rule_config) : rule_config;
                if (rule.validateConfig) {
                    rule.validateConfig(rule_config);
                }
            }
            this.activated_rules[rule.name] = {
                ...rule,
                severity: get_severity(rules_config[rule.name]),
                config: rule_config
            };
        }
    }
    generateLegacyConfig(config) {
        const o = {};
        const keys = Object.keys(config.rules);
        keys.forEach((rule_name) => {
            const rule = this.getRule(rule_name);
            const newConfig = config.rules[rule_name];
            let rule_config = extract_rule_config(newConfig, rule_name);
            if (rule_config === null) {
                rule_config = newConfig;
            }
            else {
                rule_config = rule.configTransform ? rule.configTransform(rule_config) : rule_config;
            }
            o[rule_name] = rule_config;
        });
        o.maxerr = config.maxerr;
        o["text-ignore-regex"] = config["text-ignore-regex"];
        o["raw-ignore-regex"] = config["raw-ignore-regex"];
        o["attr-name-ignore-regex"] = config["attr-name-ignore-regex"];
        o["id-class-ignore-regex"] = config["id-class-ignore-regex"];
        o["line-max-len-ignore-regex"] = config["line-max-len-ignore-regex"];
        return o;
    }
}
exports.default = Config;
