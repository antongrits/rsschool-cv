"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.has_parent_node = exports.node_tag_name = exports.get_classes = exports.attribute_has_value = exports.has_attribute = exports.get_attribute = exports.is_self_closing = exports.is_directive_node = exports.is_comment_node = exports.is_text_node = exports.is_tag_node = exports.attribute_value = exports.has_non_empty_attribute = void 0;
const domelementtype_1 = require("domelementtype");
const util_1 = require("util");
const { isRegExp } = util_1.types;
/**
 * Check if a node is self closed or not (`<hr />, <input ... />, <foo />`)
 */
function is_self_closing(node) {
    const openRaw = node.open.raw; // Force raw presence for Element?
    return /\/>$/.test(openRaw);
}
exports.is_self_closing = is_self_closing;
/**
 * Check whether the given tag has an attribute with the given
 * name.
 */
function has_attribute(node, attribute_name) {
    return is_tag_node(node) ? node.attributes.some(({ name }) => name.chars.toLowerCase() === attribute_name) : false;
}
exports.has_attribute = has_attribute;
/**
 * Check whether the given tag has a non-empty attribute with the given
 * name. Count `""` as a non-empty attribute value only if optional
 * parameter allow_null is true
 */
function has_non_empty_attribute(node, attribute_name, allow_null = false) {
    const attribute = node.attributes.find(({ name }) => name.chars.toLowerCase() === attribute_name);
    return !!attribute && (allow_null || (!!attribute.value && attribute.value.chars.length > 0));
}
exports.has_non_empty_attribute = has_non_empty_attribute;
// Find a way to make this generic
// type LangAttribute = { chars: 'lang' } & NodeAttribute ;
/**
 * Get an attribute of a node element
 */
function get_attribute(node, attribute_name) {
    if (has_attribute(node, attribute_name)) {
        return node.attributes.find(({ name }) => name.chars.toLowerCase() === attribute_name);
    }
    return null;
}
exports.get_attribute = get_attribute;
/**
 * Get the value of an attribute for a specified node element
 */
function attribute_value(node, attribute_name) {
    var _a;
    const attribute = get_attribute(node, attribute_name);
    return (_a = attribute === null || attribute === void 0 ? void 0 : attribute.value) !== null && _a !== void 0 ? _a : null;
}
exports.attribute_value = attribute_value;
/**
 * Check whether an attribute has a value or not
 */
function attribute_has_value(node, attribute_name, value_to_check) {
    const value = attribute_value(node, attribute_name);
    if (value) {
        return isRegExp(value_to_check) ? value_to_check.test(value.chars) : value.chars === value_to_check;
    }
    return false;
}
exports.attribute_has_value = attribute_has_value;
/**
 * Check if a node is an Element node (div, span,... + style and script)
 */
function is_tag_node(node) {
    return [domelementtype_1.ElementType.Tag, domelementtype_1.ElementType.Style, domelementtype_1.ElementType.Script].indexOf(node.type) !== -1;
}
exports.is_tag_node = is_tag_node;
// TODO: check is current node text have `.loc` property if yes then create class Text_Node in dom_element.ts
/**
 * Check if a node is a Text node
 */
function is_text_node(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.is_text_node = is_text_node;
/**
 * Check if a node is a Comment node (`<!-- a comment -->`)
 */
function is_comment_node(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.is_comment_node = is_comment_node;
function is_directive_node(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.is_directive_node = is_directive_node;
// TODO find a way to have template type NodeAttribute<"class">
/**
 * Extract all html class for the class attribute
 */
function get_classes(class_attribute) {
    var _a, _b;
    const classes = (_b = (_a = class_attribute === null || class_attribute === void 0 ? void 0 : class_attribute.value) === null || _a === void 0 ? void 0 : _a.chars) !== null && _b !== void 0 ? _b : "";
    return classes.trim().split(/\s+/);
}
exports.get_classes = get_classes;
/**
 * Return the name of a node (Comment, Text node, div, span...)
 */
function node_tag_name(node) {
    switch (node.type) {
        case domelementtype_1.ElementType.Text:
            return "Text Node"; // get text node content but truncate ?
        case domelementtype_1.ElementType.Comment:
            return "Comment";
        default:
            // TODO: Check function with other types (CDATA, doctype...)
            return node.name;
    }
}
exports.node_tag_name = node_tag_name;
/**
 * Check if a node has a parent node
 */
function has_parent_node(node) {
    // root node is not a "normal" node
    return !!node.parent && node.parent.type !== "root";
}
exports.has_parent_node = has_parent_node;
